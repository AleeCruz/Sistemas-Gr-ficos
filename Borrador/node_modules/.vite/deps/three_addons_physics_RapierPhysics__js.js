import "./chunk-K7ME44FN.js";
import {
  Clock,
  Matrix4,
  Quaternion,
  Vector3
} from "./chunk-O436JUYK.js";

// node_modules/three/examples/jsm/physics/RapierPhysics.js
var RAPIER_PATH = "https://cdn.skypack.dev/@dimforge/rapier3d-compat@0.12.0";
var frameRate = 60;
var _scale = new Vector3(1, 1, 1);
var ZERO = new Vector3();
var RAPIER = null;
function getShape(geometry) {
  const parameters = geometry.parameters;
  if (geometry.type === "BoxGeometry") {
    const sx = parameters.width !== void 0 ? parameters.width / 2 : 0.5;
    const sy = parameters.height !== void 0 ? parameters.height / 2 : 0.5;
    const sz = parameters.depth !== void 0 ? parameters.depth / 2 : 0.5;
    return RAPIER.ColliderDesc.cuboid(sx, sy, sz);
  } else if (geometry.type === "SphereGeometry" || geometry.type === "IcosahedronGeometry") {
    const radius = parameters.radius !== void 0 ? parameters.radius : 1;
    return RAPIER.ColliderDesc.ball(radius);
  } else if (geometry.type === "CylinderGeometry") {
    const radius = parameters.radiusBottom !== void 0 ? parameters.radiusBottom : 0.5;
    const length = parameters.height !== void 0 ? parameters.height : 0.5;
    return RAPIER.ColliderDesc.cylinder(length / 2, radius);
  } else if (geometry.type === "CapsuleGeometry") {
    const radius = parameters.radius !== void 0 ? parameters.radius : 0.5;
    const length = parameters.height !== void 0 ? parameters.height : 0.5;
    return RAPIER.ColliderDesc.capsule(length / 2, radius);
  } else if (geometry.type === "BufferGeometry") {
    const vertices = [];
    const vertex = new Vector3();
    const position = geometry.getAttribute("position");
    for (let i = 0; i < position.count; i++) {
      vertex.fromBufferAttribute(position, i);
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
    const indices = geometry.getIndex() === null ? Uint32Array.from(Array(parseInt(vertices.length / 3)).keys()) : geometry.getIndex().array;
    return RAPIER.ColliderDesc.trimesh(vertices, indices);
  }
  return null;
}
async function RapierPhysics() {
  if (RAPIER === null) {
    RAPIER = await import(`${RAPIER_PATH}`);
    await RAPIER.init();
  }
  const gravity = new Vector3(0, -9.81, 0);
  const world = new RAPIER.World(gravity);
  const meshes = [];
  const meshMap = /* @__PURE__ */ new WeakMap();
  const _vector = new Vector3();
  const _quaternion = new Quaternion();
  const _matrix = new Matrix4();
  function addScene(scene) {
    scene.traverse(function(child) {
      if (child.isMesh) {
        const physics = child.userData.physics;
        if (physics) {
          addMesh(child, physics.mass, physics.restitution);
        }
      }
    });
  }
  function addMesh(mesh, mass = 0, restitution = 0) {
    const shape = getShape(mesh.geometry);
    if (shape === null) return;
    shape.setMass(mass);
    shape.setRestitution(restitution);
    const body = mesh.isInstancedMesh ? createInstancedBody(mesh, mass, shape) : createBody(mesh.position, mesh.quaternion, mass, shape);
    if (!mesh.userData.physics) mesh.userData.physics = {};
    mesh.userData.physics.body = body;
    if (mass > 0) {
      meshes.push(mesh);
      meshMap.set(mesh, body);
    }
  }
  function createInstancedBody(mesh, mass, shape) {
    const array = mesh.instanceMatrix.array;
    const bodies = [];
    for (let i = 0; i < mesh.count; i++) {
      const position = _vector.fromArray(array, i * 16 + 12);
      bodies.push(createBody(position, null, mass, shape));
    }
    return bodies;
  }
  function createBody(position, quaternion, mass, shape) {
    const desc = mass > 0 ? RAPIER.RigidBodyDesc.dynamic() : RAPIER.RigidBodyDesc.fixed();
    desc.setTranslation(...position);
    if (quaternion !== null) desc.setRotation(quaternion);
    const body = world.createRigidBody(desc);
    world.createCollider(shape, body);
    return body;
  }
  function setMeshPosition(mesh, position, index = 0) {
    let body = meshMap.get(mesh);
    if (mesh.isInstancedMesh) {
      body = body[index];
    }
    body.setAngvel(ZERO);
    body.setLinvel(ZERO);
    body.setTranslation(position);
  }
  function setMeshVelocity(mesh, velocity, index = 0) {
    let body = meshMap.get(mesh);
    if (mesh.isInstancedMesh) {
      body = body[index];
    }
    body.setLinvel(velocity);
  }
  function addHeightfield(mesh, width, depth, heights, scale) {
    const shape = RAPIER.ColliderDesc.heightfield(width, depth, heights, scale);
    const bodyDesc = RAPIER.RigidBodyDesc.fixed();
    bodyDesc.setTranslation(mesh.position.x, mesh.position.y, mesh.position.z);
    bodyDesc.setRotation(mesh.quaternion);
    const body = world.createRigidBody(bodyDesc);
    world.createCollider(shape, body);
    if (!mesh.userData.physics) mesh.userData.physics = {};
    mesh.userData.physics.body = body;
    return body;
  }
  const clock = new Clock();
  function step() {
    world.timestep = clock.getDelta();
    world.step();
    for (let i = 0, l = meshes.length; i < l; i++) {
      const mesh = meshes[i];
      if (mesh.isInstancedMesh) {
        const array = mesh.instanceMatrix.array;
        const bodies = meshMap.get(mesh);
        for (let j = 0; j < bodies.length; j++) {
          const body = bodies[j];
          const position = body.translation();
          _quaternion.copy(body.rotation());
          _matrix.compose(position, _quaternion, _scale).toArray(array, j * 16);
        }
        mesh.instanceMatrix.needsUpdate = true;
        mesh.computeBoundingSphere();
      } else {
        const body = meshMap.get(mesh);
        mesh.position.copy(body.translation());
        mesh.quaternion.copy(body.rotation());
      }
    }
  }
  setInterval(step, 1e3 / frameRate);
  return {
    RAPIER,
    world,
    /**
     * Adds the given scene to this physics simulation. Only meshes with a
     * `physics` object in their {@link Object3D#userData} field will be honored.
     * The object can be used to store the mass and restitution of the mesh. E.g.:
     * ```js
     * box.userData.physics = { mass: 1, restitution: 0 };
     * ```
     *
     * @method
     * @name RapierPhysics#addScene
     * @param {Object3D} scene The scene or any type of 3D object to add.
     */
    addScene,
    /**
     * Adds the given mesh to this physics simulation.
     *
     * @method
     * @name RapierPhysics#addMesh
     * @param {Mesh} mesh The mesh to add.
     * @param {number} [mass=0] The mass in kg of the mesh.
     * @param {number} [restitution=0] The restitution/friction of the mesh.
     */
    addMesh,
    /**
     * Set the position of the given mesh which is part of the physics simulation. Calling this
     * method will reset the current simulated velocity of the mesh.
     *
     * @method
     * @name RapierPhysics#setMeshPosition
     * @param {Mesh} mesh The mesh to update the position for.
     * @param {Vector3} position - The new position.
     * @param {number} [index=0] - If the mesh is instanced, the index represents the instanced ID.
     */
    setMeshPosition,
    /**
     * Set the velocity of the given mesh which is part of the physics simulation.
     *
     * @method
     * @name RapierPhysics#setMeshVelocity
     * @param {Mesh} mesh The mesh to update the velocity for.
     * @param {Vector3} velocity - The new velocity.
     * @param {number} [index=0] - If the mesh is instanced, the index represents the instanced ID.
     */
    setMeshVelocity,
    /**
     * Adds a heightfield terrain to the physics simulation.
     * 
     * @method
     * @name RapierPhysics#addHeightfield
     * @param {Mesh} mesh - The Three.js mesh representing the terrain.
     * @param {number} width - The number of vertices along the width (x-axis) of the heightfield.
     * @param {number} depth - The number of vertices along the depth (z-axis) of the heightfield.
     * @param {Float32Array} heights - Array of height values for each vertex in the heightfield.
     * @param {Object} scale - Scale factors for the heightfield dimensions.
     * @param {number} scale.x - Scale factor for width.
     * @param {number} scale.y - Scale factor for height.
     * @param {number} scale.z - Scale factor for depth.
     * @returns {RigidBody} The created Rapier rigid body for the heightfield.
     */
    addHeightfield
  };
}
export {
  RapierPhysics
};
//# sourceMappingURL=three_addons_physics_RapierPhysics__js.js.map
